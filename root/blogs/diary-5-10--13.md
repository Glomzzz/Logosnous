---
date: 2024-05-13 17:55
tags:
  - 趣闻
  - 美景
  - 美食
  - 对话录
category: life
---
# 逃亡之路，定居嘉兴

爆了上海地头蛇的金币，为了我的人身安全，我必须得从上海逃离了。（中二病

随便租了个离朋友家近的房子，准备宅在家不出门了（写项目。

![[assets/blogs/diary/5-13/station.jpg]]

![[assets/blogs/diary/5-13/sunset.jpg]]

朋友请我吃了顿烧烤 😋

![[assets/blogs/diary/5-13/bbq.jpg]]
# 与 FrankHB 的讨论
完整的对话讨论我会放在[帝球对话录](blogs/chatlog-with-frankHB.md)

## FrankHB回复

 > 被长文吓了一跳。
> 
> ## 关于 Asahi
> Asahi那个项目是2年前的就代码了，我上文也说到了asahi的源码槽点很多，我想重构，最近也正在重构。
> 
> 两年前的我是个国内高一的学生，每天过着早6晚11的生活，哎，根本没有时间去系统性的学习PL，理解一下。
> 
> Asahi那个项目是从Pouvoir中分离出来的，也许Pouvoir中的Asahi版本更新，但Pouvoir那些我已经撂摊子1年多了。
> 
> 所以 Asahi的代码水平不代表我现在的水平喵。。
> 

能一直进步那再好不过。不过，大部分人，包括我在内，都会遇到瓶颈。考虑到我都会遇到这种情况，只能说问题本身难度就在那里了。

> ### 关于 "什么是脚本语言"
> 说实话我没有搞清楚，也许Asahi应该叫dsl才对嘛。。
> 
> 我最近刚开始拜读你的pl-docs（MikanAffine推荐的），也许我能从中找到我想要的答案
> 

这个问题没被强调过，可能值得单独科普，不过考虑到[部分观点早就被提过](https://www.yinwang.org/blog-cn/2013/03/29/scripting-language)，所以要点可以这里即答：

* 首先，反对“脚本语言”这个提法，纠正的是一些已经过于流行的系统认知的偏差，而不是否定具体的语言设计的目标和定位。不过，这里可能集中体现作者的局限性而应当被警觉。严肃的作者会避免这种不准确的说法。
* 第二，这个提法的直接的技术错误是把“脚本”的实现形式和语言捆绑在一起。实际上语言规范强行要求这个语言的实例只能被作为脚本实现毫无道理。日常被称为脚本语言的实例，如 shell 、Python 之类，其作为事实标准的实现都区分 REPL 和批处理的脚本模式，甚至 REPL 有时还更有用一些，直接称为脚本语言是**基本的事实判断错误**。作为正经用户能容忍这种**指鹿为马**都是很不正常的，更不用说语言设计者自己了。
	* 类似的还有“编译型语言”，虽然这个是可能写在语言规范里的，但跟流行的胡扯往往恰好相反。比如 C/C++ 被讹传为编译型语言，其实压根就不在乎什么编译，也有“解释性”的实现（Cling）；反而 Java 被日常讹传为“解释型语言”，事实 JLS 却是钦定了编译（成配合 JVM 的 bytecode ）。ISO C 和 ISO C++ 里叫 translation unit 的东西，在 JLS 里对应的是 compilation unit 。
	* 这些基本事实都能出现认知错误，只能说压根就没去看，纯纯态度问题。这就很容易判断出哪些用户是人云亦云的半桶水咣当响，即便看上去有本事设计语言的用户，也不例外。
* 第三，这个提法是对历史的无知和不尊重，重复错误的说法是在**以讹传讹**。
	* 合并指鹿为马，都是黄钟毁弃瓦釜雷鸣，毫无一点专业的态度和自觉。放在学术界横竖是个学术不端，放在工业界就商业互吹没人治了？
* 第四，上面链接里提过，对用户和整个业界也有深远的不良影响。

还是一句话：上梁不正下梁歪。要这么简单的常识性问题都没拎明白，好意思设计语言？鄙视这种层次的东西和鄙视一般民科的立场是差不多的，下游偏听偏信先不管，源头一定要遏制。

即便是非专业人士，不靠这个吃饭，也应该趁早划清界限；否则遇到更含糊微妙的问题，只会显得更加不专业，还要浪费别人资源来纠正免得继续祸害业界。

说成 DSL 一般技术上问题不大，尽管 D 有主观性。这方面反而是另一方面有个普遍的严重问题，[太多所谓的通用目的语言，D 的成分都太高了而名不副实](https://github.com/FrankHB/pl-docs/blob/master/en-US/calling-for-language-features.md#judgment-on-the-general-purposed-language)。有的是来自于系统偏差，比如 C 被认为是通用目的语言，但实际上本来也就是为了跨体系结构实现 UNIX 的 OS 实现的 DSL 而已，尽管它的特性能偶然涵盖其它领域，但根本上属于超范围挪用，且并不好用；另一方面，则是普遍的无能，导致实际上必须保守，比如 Rust 就因灵活性欠缺（比如不能通过参数化 `unsafe` 分离 memory safety 和 concurrency safety 单独配置检查）导致应用开发不那么好用而也就好意思自称系统语言，尽管它的很多设计其实是通用的。

> ## 关于我的最近
> 我这两年一直在开发PL相关的东西，但没开源。
> 
> ’最近在忙的是一个叫做 Asaka 的 JVM编译器后端。
> 
> 这个项目说来话长了，我先是实现了一套 kotlin-compiler，但只有函数，没有类成员的支持
> 
> 在和朋友( [MikanAffine](https://github.com/Bylx666/key-lang/issues?q=is%3Aissue+is%3Aopen+author%3AMikanAffine) )讨论的过程中，我突发奇想，想开发一套UAST，分离编译器的前端和后端，思路大概如下：
> 
> * 前端把source解析到一个UAST上
> * 后端基于UAST ( 以及后续IR )做优化，然后做各个codegen target的分发
> 
> 之后发现已经有前辈们做过这件事了，比如 graalVM那边的truffle
> 

具体的设计我不是很有兴趣关心，不过这个 idea 倒是我在乎的研究重点了。

Truffle 的那套其实是有资格提出和源码混着用给开发者直接访问通用 IR 的，关键是它契合 Graal 的 partial evaluation 框架（而经典优化编译器的各种 inline expansion + constant fold + ... 优化实际上可以认为是其缩水版），几乎不会有比这更通用的对一般 PL 的优化实现方法了（有也是其它更没被研究过的 metacompilation ）。而这样的 IR 要蕴含源语言的递归语法，基本就得是个 AST（graph reduction 之类属于实现细节，而且至少不太容易跟写成文本形式的源代码直接对应而不好用）。

但 Java 味儿太重的东西往往胆子很小，步子也太小。虽然 JVM 这个 target 比起更一般的物理机有很多槽点（stack based 性能弱鸡啦），不过这里我要说的是源语言不够和 IL 层次上的语义显式共享构造，会大大损失可用性的想象力。

例如，Java 这样的静态语言，对不得不静态的特性，往往需要打补丁的方式处理，这种补丁通过限定静态集合付出运行时开销来缓解设计的局限——最主要的就是“反射”；再通用点的如 CLR 的 `dynamic` 支持。这些设计的共同点是能动态确定的部分还是受到静态设计的限制，不能任意推迟到用户而非语言设计者自己决策——除非用户自己修改语言规范——这就因为兼容性维护成本等现实问题导致几乎没有可用性了。而 Graal 的那套其实是足以把任何动态语言按需静态化的，根本不用考虑被反射的特性集合具体设计是不是会扯到蛋的问题，源语言在这里的限制是多此一举，阻碍了优化实现的发挥。

匪夷所思的是，Java 其实有局部地尽量动态过——成员方法默认可以被覆盖，反而要用户注解  `final`  提示语言实现可以优化的点。这其实比 C++ 那种 `virtual` 的 dispatch table 补丁这种 leady abstraction 原则上更通用。奈何用户习惯导致工程上自觉需要 `final` 不到位，性能白白挖坑给最终用户之类的负面影响太显著，于是 C# 又改回来了。而对更通用的语言设计，其实完全可以默认 `virtual` ，在库中再默认 `final` 然后允许用户卸掉的。为什么不把 `virtual` 和 `final` 作为库特性而非得集成进核心？只能说设计者想象力和技术水平太差。其实 `class` 之类所谓 OO 特性也不需要进核心设计中（否则另一方面 Smalltalk 的灵活性倒是可以提一下），因为理论上就更复杂且没有现实合理的变通来确保这不是多此一举，在最通用的目的上这个就是过度设计，怎么都比在 lambda 演算上直接扩展来得废话多（这就是我上面鄙视 Luca Cardelli 的直接理由之一）。

更一般的情形下，我在乎的非技术效果是**确保定义何谓静态的权利能按需收归最终用户而非语言设计者**。用户放弃了再反弹还回去是另一回事，但现有的语言就是没做到。这也导致静态语言原则上一定在可用性潜力上弱于动态语言而难以最一般地通用，因为一个一般意义上通用的动态语言加上库设施改造为动态语言，要比给静态语言擦屁股返工出伪劣的不完全的动态特性（比如反射）不论在技术上还是工程上都有显著的优越性。

关于这方面如何普遍地设计，之前链接里有提到 smoothness conjecture ；关键其实是在设计中完全取消了“静态”这个概念；可以注意到这和所有经典的要求静态推理的逻辑系统，包括类型系统的观念都冲突——于是这个意义上可以确定 Curry style semantics 比 Church style semantics 更普遍正确。如果用户需要类型系统，那么应该同样欧库的机制在非确定的 stage 中允许用户自行提供，这样的 stage 实质上添加了何为“静态”的定义。

这些就不用指望通过学习而不是被坑经验来体会了。没嫌弃过起草语言规范的破事多的用户，即便能想象得出这里的过程是最强力的 AGI 都难以解决而长期需要人力，仍然是夏虫不可语冰。绝大多数语言社区的成员仍然因为过于虚心、盲从权威和缺乏想象力等原因惯为牛马——虽然不是那么可替代的高阶牛马的确能带来一些成就感能让他们忍受得下去，但我可不干——有的是更有价值的事要我去做，短期也差不多只有我能做。成为牛马的门槛使这部分人仍然占绝对少数，这是为什么看起来鲜少有人关注这些问题的主要现实原因。

题外话：再往大了说，这种难度的差异是**非对称性**的一个实例。这种现象在其它设计决策上也比比皆是，例如去掉 GC 比引入 GC 同时维持设计的一致性会难得多、类型擦除比类型推断屁事更多。一个更重要的典型实例是封装允许一种接口对应多种实现这种可能性，在实践中也是极端普遍却鲜少被普遍正确地认知的（常见误区是封装性和访问控制有关，后者其实只是一种实现，其它还有如 JS 的 weak map 等根本不用关心 name resolution 的机制）。这种普遍的形而上的存在性是我坚持 PL（而非体系结构或者形而下的算法模型）作为 CS 在普遍的计算模型以上的**最**核心具体分支的主要理由之一。巧的是，当代物理学也在乎非对称性（或者说，**对称性自发破缺**）的人择后果（要是正物质和反物质的存在对称，那世界只有一坨光子了），从这个意义上 CS 不再像是应用数学的延伸（虽然计算模型这部分本就不是，而应当是数学中的数学基础），反而更像是自然科学（即便我不待见这个方向）。直觉上回答为什么存在非对称性（以及费马原理这样的最普遍的规律）同属第一推动力，是超越建立大一统理论的一系列终极问题之一，这已经被不少物理学家认识到（比如杨振宁就是成功混到这口饭吃的杰出代表人物，尽管其实也就是能成功提问，而没谁在回答上有什么实质进展）；遗憾的是，数学和 CS 在这里却比形而下的物理学（形而上学=metaphysics，物理学显然不meta）还落后，让我多少对当代数学家和所谓理论 CS 学家的格局的小器觉得有些不爽了。

> 我想先根据自己的感觉写出一个能用的成品（例如Asaka），之后再去系统性地学习。
> 
> 截止到4月前，我都在开发Asaka，已经基本开发完毕，但4月后我开始忙留学事务，就再没有精力继续写项目了。
> 
> 最近是offer刚下来，我终于有时间和精力继续编写了，哈哈哈。
> 
> 哦，我现在把Asaka开源一下，但我记得我还没debug完，所以这目前只是个半成品。。。
> 

这可能其实是你现阶段最合适做的，因为说实话，我不觉得 PL 有什么系统性能重复参照的顶层成熟知识体系……很多理解连形式化我都嫌烦，用人话说根本是罄竹难书，到位程度和你被坑了多少正相关，而对想象力不那么天选之人的用户来讲，实际做确实是最有效的积累原始经验而足够入门的办法。（找错门就另一回事了。）

> ## 关于我的未来
> 我学PL，写PL，不是为了就业，也不是为了赚钱，这是知识我的爱好，满足我的求知欲，我很好奇！
> 
> 我很感谢我父母给我创造的条件，可以让我无忧无虑的探索这个世界，探索PL，不用担心就业问题。
> 
这个是比我舒服多了，虽然我同样没这方面焦虑……

但是我有一点没法绕过去：要是不干出点只有我能做的，四舍五入不就是我比别人被坑得多了那么多了的不愉快体验，都白给了？（特别是给人科普半天鸡同鸭讲，结果只能当猴子的时候。）

年轻人就是好，但如果想要变强，可能迟早都是一条道走到黑，而且光是到我这样的程度，不献祭些什么东西的话都可能是小概率事件了。希望你能保持住好奇心。

> ## 关于你
> FrankHB，其实你算作我们年轻PL一代的老前辈了。
> 
> 我3月多从朋友那了解到你的pl-docs，之后一直想读，可惜被接踵而至的留学材料耽搁了。
> 
> 不过现在有时间读了。
> 
实际上吧，这仓库主要是重复了太多的~~废话~~观点的集合，顺便把体例搞得正式一些方便引用，所以对层次的水平不要有奇怪的预期，更别指望有多少系统性。

即便每次我都能毫无压力地长篇大论换法子保持要义不走样（而不是 yinwang0 隔了没几天就自己打脸了），DRY 也是必要的生产力。

> ## 关于你的建议
> ### 我的理论建设
> 我想加强自身理论知识的建设，也想学习更多知识，你的话戳中了我的内心，戳中了两年前那个好高骛远的我。
> 
> 其实在这一年多和朋友们交流的过程中，我早已意识到自己的理论知识严重不足，我个人感觉是我根本没有什么理论知识。
> 
> > 比这里的小朋友快一点 / 要我来看门都没怎么入
> 
> 哎，要我看来：
> 
> * 我真不一定有人家快。
> * 我都不知道门在哪里。
> 

大多数人是谁都不比谁更快。

门在哪主要看你的目的。这里绝对低级的民科并不那么常见，所以只是一个细分领域其实不会那么容易被误导。

但是，很多分支，如果没有实际需求，在更大的场景中可能就是缺乏长期意义的。更普遍的现象是局部的进展会被重复偶然地发现，新事物闹个大煋闻，未必就更先进。

举一个纯 PL 具体特性设计的（且有必要众所周知的）例子：因为解决不了 funarg proglem 这个实现问题，ALGOL-like 语言对函数这种构造做了很多限制，全然不管 1930 年代就有的 lambda abstraction 早就统一了基本设计，而 1954 年 SECD machine 的 closure 原则上就扫清了实现的障碍（如果配合 environment 的扩展，后面 OO 那些 class 都是多余的，所谓 class 的 object 一定程度上其实就是“带有符号表注释的”closure object ）——虽然 LC 并没有正经被作为 PL（John MaCarthy 都提过他其实都不太懂 LC ）而扩展 LC 作为 operational semantics 方面的工作直到 1970 年代才开始被开展，使实际的设计更贴近正式的模型，实在太后进了。结果到了 2010 年代前后（如 Java 和 C++ ）都还在搞什么 lambda expression ，后知后觉丢人不丢人？要是一开始就理清楚脉络，就没那么拖沓的事了。

更多炒冷饭，如 actor model 炒 continuations（的一部分）、coroutine（的另一部分）炒continuations（的另一部分）、algebriac effects 炒 delimited continuations ……在把这些不同表述都看过就知道多蛋疼了。

可能容易注意到 continuations 出现了多次（被炒）。这说明它始终欠缺主流用户的充分理解。作为外行对此理解困难就算了，作为 researchers 这么炒冷饭，就说明在系统归并知识结构上，整体做得很不够。

所以在缺乏系统知识体系的现成材料的情况下，我能给的可能鲜少被强调的经验是：注意主线，无论是历史还是具体的知识结构上。

* CS 的核心概念自然是计算。历史上定义计算的主线的标志性事件是 Church-Turing thesis 的确立，因为在这个元命题之前计算的概念是没法严格的，这框定了计算的范围，要再有疑问就是哲学问题。
	* 但还有个隐含的主线：计算涵盖逻辑，而不是反过来——存在偏可计算函数，而不存在有意义的偏证明。这又是一种*非对称*。
* CS 最重要的研究对象的主线是计算模型，[而 PL 面对的模型是其中最直接普遍的一类研究对象，其它如体系结构模型和算法模型通常相对更加形而下](https://www.bilibili.com/read/cv26671044/)，对整个 CS 结构的观念有一定作用。
* [(UT)LC](https://en.wikipedia.org/wiki/Lambda_calculus) 是最重要的计算模型，没有之一，因为它衔接了多个 CS 子领域甚至外部的学科。
	* 其实最早发明 LC 的理由就是逻辑系统，甚至 Church 本人还魔怔了想继续砍成更纯粹的逻辑反而弱化了计算。而削弱的模型其实就是排除了偏可计算函数。
	* LC 引入了 Church-Turing thesis 的一端，事实上最早定义了计算。
	* LC 第一个被普遍研究的项重写系统（这本身作为演绎系统的实例，算是逻辑问题，但能不停机……就涉及完全体的计算了）。
	* 对 PL 来说，LC 是最重要的操作语义模型，因为它事实上定义了高级语言（有变量和函数抽象）。仅仅更简单了一点点的组合子逻辑，就是低级语言了。同时，strict evaluation 等很多 PL 中的共通特性的研究始于对 LC 的操作语义（LC 中很多效果没区别，但引入副作用就有区别了）。
	* 对扩展操作语义模型和直接通过扩展模型严格定义新语言，LC 是无可争议的起点（基本就没找到别的值得一提的相关工作）。
	* 对类型系统研究来说，UTLC 的直接扩展 STLC 是研究类型推理和类型系统设计的起点。[Church style vs. Curry style](https://ericnormand.me/article/church-vs-curry-types) 这样的普遍的元问题也是针对 STLC 。STLC 还是 lambda cube 和很多更复杂系统之间的初始原点。
	* 这是无可争议的主线核心，因为**从各个领域来看，到处都会遇到，根本就绕不过去**。这方面系统学习，有一本 Henk Barendregt 的通称为 bible 的书，不过过于强调逻辑侧其实并不都需要很深入。但对这些复杂知识网络的非线性章节的写作风格倒是值得留意。
	* 更普遍地，LC 可以替代公理集合论和作为严格的数学基础。它没有集合论需要外挂逻辑语言的缺陷，也没有范畴论过分强调对偶(duality) 而削弱非对称性的缺陷，没有 HoTT 这样强调具体个别数学分支而难以被非职业数学家接受的缺陷，在工程化上，是合并传统数学、CS乃至一部分分析哲学的公共基础的首选。
* 在[抽象理论](https://web.cs.wpi.edu/~jshutt/abstraction-theory.html)的基础上，我进一步猜想 LC 可能是满足上述许多组预期意义的唯一的解，而没有其它替代的非等价模型存在碰瓷的可能性；并且主线的有限性是能进一步添加条件扩展 LC 而严格定义的。当然以一整个带约束的形式系统作为解的问题远远超出现有蓝星数学水平了，我也不打算填坑……可能得基于这些理论的分析式（而非现在鼓吹的生成式炼丹）AGI 成熟之后才可能解决这些鸡和蛋的问题。

（完全新手要入门语言[倒是有另外挖过坑](https://github.com/FrankHB/pl-docs/blob/master/zh-CN/introduction-to-learning-computer-languages.md)……）

可以看到，门是可以强行定义出来的，但这个门肯定不是你要入的 PL 的门，而是现在几个最顶层学科都有很大优化空间的普遍问题。这也是你容易发现为什么那么稀碎的原因……因为 PL 在根本上确实广到能和这些学科都有一腿……

> ### 关于从fp取经
> 其实我想从fp那里取的经， 我也不好说是什么，我只是从群友那边了解到 fp 这里也许有我想要的东西。
> 
> 最近刚开始学 Haskell (Real world Haskell) , 抱歉截止目前我刚读到第三章（毕竟才第3天。。）
> 
> 我觉得等我学完，也许可以得到一份让我满意的答卷吧，关于"我要取什么经"。

Haskell 开开 PFP (purely functional programming) 的眼界可以碰，但不要信 pure 就一定更好的鬼话。

抛开大多数用户对引用透明的理解的肤浅性（简而言之并不一定需要 PFP 才能引用透明）这些具体旮旯，这里更涉及到更深层次的哲学（元数学）问题。PFP 移除了副作用，那么是不是 pure 就更基础，impure 就是扩展？

在我看来不是。因为[不可分的同一性](https://plato.stanford.edu/entries/identity-indiscernible/)（这也就是上面唐突乱入的那部分分析哲学的核心），从实体上砍掉区分同一性其实是不那么难的（具体来说就是 interning ），但加回去就不那么容易了——理论上需要支持*任意多种不确定的副作用*，在扩展上其实是不可行的。先承认存在一种支持任意副作用的平凡极限作为基线，这才比较正常。注意，这*又是一种非对称性*。

而 Haskell 这样的 PFP 设计恰恰在原则上不可能解决这个问题。

另一个深层问题是，Haskell 引入 PFP 配合 lazy evaluation 才有用——而鲜少有人意识到这是为了做 equational reasoning ，即便这会使他们在压根没用上的时候也付出代价（比如浪费寄存器）。滥用 laziness 和滥用 AI 指望问题会自然消失在方法论上的谬误是相似的。实际上只有相当相当少数典型问题才方便忽略这种代价而更少有领域适合这么用（比如 nixpkgs 之类），因此 lazily PFP 语言注定只能是具有相当强限制的 DSL 。ML 系这样的 eager PFP 语言在这里问题就不那么显著。
 
顺带一提，能作为我 CS 精神导师的只有两位：提出 UTLC 的 Alonzo Church ，以及首先在系统化扩展 UTLC（在 lambda abstraction 上直接动刀而不是添加 operator 的小修改）并以此设计通用 PL 的 John Shutt 。后者同时是 adaptive grammar 的主要贡献者以及抽象理论的提出者。

关于后者，我是在我自己闭门造车得差不多的情况下才在 fexpr 的相关文献中看到有类似的东西，而且这是我生涯头一次遇到在我感兴趣到 all-in 的领域总进度比我超前以至于还能得到不少新 idea 的状况。

不过在这里提到，还有一个原因是他有[一篇综述论文](https://news.ycombinator.com/item?id=18405014)的第一部分比较适合入门 PL research 的 LC ，还集中引用了很多历史参考文献。虽然大都我都早就知道了，不过里面还是有很多不那么容易自己 get 的问题（比如 context 在一般意义上就是个 formal hole 之类）。可能链接有问题就 wayback time machine 一下吧……

> 
> ## 顺带一提
> 我目前没有找到中文互联网上有系统性的PL入门教学。
> 
不只是中文。你看了上面提到的主线普遍得离谱，就不可能知道存在单一的门（因为跨度太广，这是未决问题——甚至涉及到把整个数学形式化），而只会有碎片化的方向。

当然，或许也就是长期被碎片化的知识坑，所以我才对浪费的资源那么记仇，反而能因为抠门的反应和不需要为了 paper 挖恰好不大不小的 idea ，最终接触到比任何具体有名门师承的科班 PL 同学远远更广的视野（而不是我涉猎范围的具体深度差距，都不够我拿工业语言解决问题的经验爆锤的）。

> ### 有多系统？
> 最起码来说，总结出来PLT中都有哪些领域，领域下都有哪些成果。
> 
> 有个姓liu的朋友给我稍微罗列了一下，确实又多又杂，有几个领域甚至根本互相不沾边的。
> 
> ### 有多入门？
> 以类型系统这个领域为例
> 
> * 从 lambda演算 开始（我目前甚至不确定这是算不算门。）
> * 从 什么是类型 开始 （我见到pl-docs里有这部分）

类型的部分，大概 TAPL 吧。不过实际上我基本都只看维基百科里的历史部分直接还原出来的。

真要看完整的历史就很麻烦了，毕竟类型本身是集合论填坑然后又被捡起来的东西。还有 nlab 上的不少比维基百科还要容易看着看着就走神到其它链接上的文章（过于数学警告）。

> 
> 我希望在我学习过程中，可以积累出来一些系统且入门的文档，供后人参考，为提高蓝星人PL素质的下限尽绵薄之力。
> 

在整个 PL 上系统且入门就别想太多了，因为 PL 整体确实是“反紧凑”的。

如果你能整理出靠谱的笔记那是大功一件。不过蓝星人关于 PL 的素质还有很大一部分是对工业语言的应用 flavor 和 taste 都实在太差，还喜欢迷信权威跟风。这就不好通过文献解决了。

> ## 从哪里可以看到我的进展？
> 你可以从我最近的 contribution里看到我最近在忙什么。
> 
> 我这几天在忙一个叫 Librorum 的项目，是一个静态文档站点生成器(markdown)
> 
> 目前已经可以投入生产环境使用了。
> 
> 过几天你就可以访问 glom.skillw.com 来观看我每天的日记和感想了。
> 
> 哎，感谢FrankHB给我发的长评，好感动哦。。。
> 
> 可以加一下我qq嘛，88595433，我想和你促膝长谈喵~

因为是可能复用的公共信息，具体项目的 issue 里提话题要求更合适。

当然，挖坑肯定比填坑效率高，不保证填得完（

@jellyterra 不用担心，目测长期会处于我向业界怒送中指哀其不争的状况，可能少说一代人，你们运气好估计还是有机会打扫战场捡败者爆的金币的……

_Originally posted by @FrankHB in https://github.com/Bylx666/key-lang/issues/28#issuecomment-2105091311_
            

## 我的回复

今天一整天都在搬家，很累。

---

### 关于非良定义词汇的滥用

这几天和朋友们讨论过这个问题，我深深地意识到了自己的错误。

lyzh：
> 水货的教育系统，搞出来水的概念都搞不清的人
> 市面上烂大街的三流知识到处流传

诶，水货，我是实实在在的水货。

感谢你们让我再次意识到这点，
在这之前我貌似根本没有彻底认清我说的某些词汇究竟代表什么。

现在我也非常讨厌非良定义的东西被滥用了。

看来我得重新好好地审视一下我自己了。( 我的态度有根本上的问题。 )

我会记住这段话的：

> 上梁不正下梁歪。要这么简单的常识性问题都没拎明白，好意思设计语言？
> 鄙视这种层次的东西和鄙视一般民科的立场是差不多的，
> 下游偏听偏信先不管，源头一定要遏制。

### 关于我的学习

#### 关于Asahi

我会改称为dsl的，脚本语言属实欠妥了，我了解到脚本语言这玩意就不是个良定义的东西。

（？）： 从某个角度来说，C++甚至也算脚本语言。

同时要给Asahi加的一些feat我会以issue的形式公开。
例如 PFP + lazy evaluation 是一定会引入的了。


#### 另一条路

我这边有个4人团队（和我年龄相仿），正在画一个VM的饼(从4月开始)，这个饼的定位是比JVM更底层一点或者和JVM一致。目的和我的asaka一样，是为了学习。


有个很年轻的成员[LizBing (Lei Zaakjyu) (github.com)](https://github.com/LizBing/) 已经自己开始实现了。（用Rust + C）

#### 关于Asaka

哎，不要期待这玩意，这只是我的练手玩具，用来进一步熟悉编译器后端的东西，目前和truffle比不了。

#### 其实我想借项目实践学更多东西

可能要花费很长时间了。
##### IR
会接触更多层IR，不同的IR。

（当然target如果是JVM bytecode的话属实没这个必要，我是为了学习。）
##### IR Pass

预计会很复杂，目前Asaka的太乱了要被重构的。
##### Codegen Target
目前Asaka在计划内的target有JVM bytecode和LLVM。

target预计会再加一个我们的VM bytecode
##### And more...
- [新坑 - Partial Evaluation教程 (zhihu.com)](https://zhuanlan.zhihu.com/p/642826067)
- GC
- JIT
- AOP
- ...

如你所说

> 实际做确实是最有效的积累原始经验而足够入门的办法。


### 自发秩序与建构秩序

> 后知后觉丢人不丢人？要是一开始就理清楚脉络，就没那么拖沓的事了。

我是个很喜欢建构秩序的人，我总觉得自发秩序的效率不如建构秩序。

我在各种方面都偏向建构秩序，例如经济上我更喜欢让有形的大手做点宏观调控（
（还有其他方面，但我觉得跑题了且有可能会引起意识形态对立，暂且不提了。）

当然建构秩序很考验建构的人的水平，但像上面那几位找错了门就很难绷了。

所以下面这句话很重要：

> 注意主线，无论是历史还是具体的知识结构上。

### 待学习/被坑

> 这边我删掉了一大段话，我觉得应该等我多了解一些后再去和你讨论。

- **确保定义何谓静态的权利能按需收归最终用户而非语言设计者**
- Lambda演算
- Haskell
- and more...

（其实我觉得我应该单独开个项目，一个个提issue。）


抱歉，我的知识储备还不足在这些领域以和你展开酣畅淋漓地讨论。

我会加把劲的。

我每日所见所学所感所悟都会记录在我的博客上，欢迎关注。















