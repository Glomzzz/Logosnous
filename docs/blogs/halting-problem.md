---
date: 2024-06-04 18:14
tags:
  - 算法
  - 停机问题
category: tech
icon: /public/assets/docs/blogs/halting-problem.jpg
---
# 为什么不存在解决停机问题的通用算法？

## 前言

写这篇文章是看到了一个知乎上的回复：

> [初识计算机中的“停机问题” - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/560379995)

> 我知道停机问题不可解是有定论的，但是不理解反证法为什么可以证明停机判定程序H不存在？不能因为是反例程序U自己的问题吗？ 比方说我说“不存在一个程序H可以正确完成1+1=2”，证明如下：先假设H程序可以正确完成1+1=2，然后构造一个程序U，当输入1+1时，调用H程序，把结果2再人为加1（对应U人为地把H的判定结果取反），最终输出3，所以这就证明了正确解答1+1=2的程序H不存在？难道不是U自己的程序有问题吗？ 再比方说有个绝对灵验的算命先生，你为了证明世界上不存在绝对灵验的算命先生，就问算命先生：“你猜我会不会给你钱？”，如果算命先生说给你就不给，如果算命先生说不给你就给。 我觉得这样证明不了世界上不存在算命先生的，合理验证方法当然应该是算命先生不告诉你答案，把答案写在纸上让你回家再打开，就知道算命先生算得准不准了。 所以我觉得把万能的停机判定程序H的判定结果事先告诉被判定程序U来证明不存在万能的停机判定程序H，这个逻辑我有些理解不了，请帮我再看看哪里理解错了，谢谢

## 什么是停机问题

我们首先要明确我们在讨论什么。

**停机问题**（英语：halting problem）是[逻辑数学](https://zh.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91 "数理逻辑")中[可计算性理论](https://zh.wikipedia.org/wiki/%E5%8F%AF%E8%AE%A1%E7%AE%97%E6%80%A7%E7%90%86%E8%AE%BA "可计算性理论")的一个问题。通俗地说，停机问题就是判断任意一个[程序](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F "程序")是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者[死循环](https://zh.wikipedia.org/wiki/%E6%AD%BB%E5%BE%AA%E7%92%B0 "死循环")。

其实完全可以在高中数学的逻辑体系下解答：

看到这个程序P存在的条件是**要能满足可以判断任意程序w是否能停机**。
所以要证伪这个命题，我们只需找出一个反例即可。

那么我们构造出一个程序U即可。

```C
// 程序P
int P(w,w_args); // 这里的P函数有两种返回值，不停机(0) 或 停机(1)

// 我们构造出来的反例，程序U
int U(f)
{
    //P(f,f) == 0时则跳出循环，程序正常结束；P(f,f)==1时则进入死循环中。
    while(P(f,f)){}
    return 0;
}
```

显然，停机问题是符合排中律的（因为不可能存在一个即停机又不停机的程序）  

所以，分两种情况分类讨论：
- 当**程序U**可以停机时 -> `P(U,U)` 返回1（判断为可以停机）-> 但实际上 `U(U)`确会陷入死循环，是不停机的。
- 当**程序U**不可以停机时 -> `P(U,U)` 返回0（判断为不可以停机）-> 但实际上 `U(U)`确会直接返回0，是停机的。

可见两种情况下，**判断程序P** 均做出了错误的判断，所以**程序P**永远不能判断出**程序U**是否能停机

所以：

不存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者[死循环](https://zh.wikipedia.org/wiki/%E6%AD%BB%E5%BE%AA%E7%92%B0 "死循环")

也就是说，**没有一个通用算法能判断出任意一个程序是否能停机**。

## 拓展-一些相关的芳斯塔芙

todo....